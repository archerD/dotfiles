{ config, pkgs, ... }:
{
  # Bootloader.
  boot.loader = {
    efi.canTouchEfiVariables = true;
    efi.efiSysMountPoint = "/boot/efi";
    timeout = 15;

    # systemd boot loader config
    systemd-boot = {
      enable = false;
      windows = {
        "windows" = {
          title = "Windows";
          sortKey = "z_windows";
          # To determine the name of the windows boot drive, boot into edk2 first, then run
          # `map -c` to get drive aliases, and try out running `FS1:`, where `FS1` is an alias,
          # then `ls EFI` to check which alias corresponds to which EFI partition (Microsoft/
          # should be in the correct device handle).
          efiDeviceHandle = "FS1";
        };
      };
      configurationLimit = 5;
      edk2-uefi-shell.enable = false;
      edk2-uefi-shell.sortKey = "y_edk2";
    };

    # grub boot loader config
    grub = {
      enable = false;
      devices = [ "nodev" ];
      efiSupport = true;
      useOSProber = true; # allows automatic detection of other OS's for booting
      configurationLimit = 10;
    };
  };

  # lanzaboote boot loader, for secure boot support
  boot.lanzaboote = {
    enable = true;
    # keys generated by running sudo sbctl create-keys, and placed in /etc/secureboot
    pkiBundle = "/etc/secureboot";
    # NOTE: for windows booting on a separate drive, the edk2-uefi-shell needs to be signed manually
    # It can be generated using the systemd setup above, and signed using sbctl:
    # `sudo sbctl sign -s /boot/efi/EFI/edk2-uefi-shell/shell.efi`
    # assuming the given path is the path to the edk2-uefi-shell entry.
    # The -s flag is not taking the path it is telling sbctl to save the signed file to the database.
  };

  environment.systemPackages = [
    # for setting up, debugging, and troubleshooting Secure Boot.
    pkgs.sbctl
  ];
}
