# shbang added by nix.

### Mostly generated by multiple interactive passes with google ai...

# --- Configuration ---
SCRIPT_NAME=$(basename "$0")

# Function to display usage information
usage() {
    echo "Usage: $SCRIPT_NAME SOURCE..."
    echo "Options:"
    echo "  <none> : Backup (copy, incremental)"
    echo "  -f     : Force backup (copy, overwrite latest)"
    echo "  -m     : Use 'mv' instead of 'cp' for backup (consumes source file)"
    echo "  -r     : Restore (move, consumes backup file)"
    echo "  -s     : Swap current file with latest backup"
    echo "  -d     : Delete only the latest backup file"
    echo "  -D     : Delete all backup files"
    echo " -f can also modify other operations (force deletes when source does not exist, force restore of existing source file)"
    exit 1
}

# Function to find the latest (highest numbered) backup file path
find_latest_backup() {
    local file_to_check="$1"
    local latest_bak=$(ls -v "${file_to_check}.bak"* 2>/dev/null | tail -n 1)
    echo "$latest_bak"
}

# --- Argument Parsing (Manual Loop) ---
MODE="BACKUP"
FORCE_REPLACE=0
USE_MV_FOR_BACKUP=0
# Array to store just the filenames
FILENAMES=()

# Iterate through all arguments provided
while [ "$#" -gt 0 ]; do
    case "$1" in
        -f|--force)
            FORCE_REPLACE=1
            shift
            ;;
        -m|--move-backup)
            USE_MV_FOR_BACKUP=1
            shift
            ;;
        -r|--restore)
            MODE="RESTORE"
            shift
            ;;
        -s|--swap)
            MODE="SWAP"
            shift
            ;;
        -d|--delete-latest)
            MODE="DELETE_LATEST";
            shift
            ;;
        -D|--delete-all)
            MODE="DELETE_ALL";
            shift
            ;;
        -*)
            # Handle unknown flags
            echo "Error: Unknown option $1" >&2
            usage
            ;;
        *)
            # This is a filename, add it to the array
            FILENAMES+=("$1")
            shift
            ;;
    esac
done

if [ ${#FILENAMES[@]} -eq 0 ]; then
    echo "Error: You must provide at least one filename."
    usage
fi

# --- Core Logic Function (Remains the same as previous response) ---
process_file() {
    local SOURCE_FILE="$1"
    echo "--- Processing: $SOURCE_FILE (Mode: $MODE) ---"

    if [[ "$MODE" != "RESTORE" && "$MODE" != "DELETE_LATEST" && "$MODE" != "DELETE_ALL" ]] && [ ! -e "$SOURCE_FILE" ]; then
        echo "Error: Source file '$SOURCE_FILE' not found for requested operation. Skipping."
        return 1
    fi
    if [ "$FORCE_REPLACE" -ne 1 ] && [[ "$MODE" != "DELETE_LATEST" && "$MODE" != "DELETE_ALL" ]] && [ ! -e "$SOURCE_FILE" ]; then
        echo "Error: Source file '$SOURCE_FILE' not found for requested delete. Skipping. (pass --force to delete)"
        return 1
    fi

    if [ "$MODE" == "DELETE_LATEST" ] || [ "$MODE" == "DELETE_ALL" ]; then
        if [[ "$MODE" == "DELETE_ALL" ]]; then
            echo "Deleting all backups for '$SOURCE_FILE'..."
            rm -f "${SOURCE_FILE}.bak"*
            if [ $? -eq 0 ]; then echo "All backups deleted."; else echo "Error deleting backups."; fi
            return 0
        fi

        local LATEST_BACKUP=$(find_latest_backup "$SOURCE_FILE")
        if [ -z "$LATEST_BACKUP" ] || [ ! -e "$LATEST_BACKUP" ]; then
            echo "Error: No backup files found for '$SOURCE_FILE'. Skipping delete."
            return 1
        fi
        if [[ "$MODE" == "DELETE_LATEST" ]]; then
            echo "Deleting latest backup: '$LATEST_BACKUP'..."
            rm -f "$LATEST_BACKUP"
            if [ $? -eq 0 ]; then echo "Latest backup deleted."; else echo "Error deleting latest backup."; fi
            return 0
        fi
    fi

    if [ "$MODE" == "RESTORE" ] || [ "$MODE" == "SWAP" ]; then
        local LATEST_BACKUP=$(find_latest_backup "$SOURCE_FILE")
        if [ -z "$LATEST_BACKUP" ] || [ ! -e "$LATEST_BACKUP" ]; then echo "Error: No backup files found for '$SOURCE_FILE'. Skipping operation."; return 1; fi

        if [ "$MODE" == "SWAP" ]; then
            TEMP_FILE=$(mktemp --tmpdir=. "${SOURCE_FILE}.temp.XXXXXXXX")
            if [ $? -ne 0 ]; then echo "Error: Failed to create a safe temporary file for swap operation. Skipping."; return 1; fi
            echo "Swapping current '$SOURCE_FILE' with latest backup '$LATEST_BACKUP'..."
            mv "$SOURCE_FILE" "$TEMP_FILE"
            mv "$LATEST_BACKUP" "$SOURCE_FILE"
            mv "$TEMP_FILE" "$LATEST_BACKUP"
            echo "Swap complete."
        else
            local COMMAND="mv -i"
            if [ "$FORCE_REPLACE" -eq 1 ]; then
                COMMAND="mv -f"
            fi
            echo "Restoring backup '$LATEST_BACKUP' to '$SOURCE_FILE' (using '$COMMAND')..."
            $COMMAND "$LATEST_BACKUP" "$SOURCE_FILE"
            if [ $? -eq 0 ]; then echo "Restore successful. Backup file '$LATEST_BACKUP' no longer exists."; else echo "Error: Restore failed."; fi
        fi
    else
        local TARGET_BACKUP=""
        if [ "$FORCE_REPLACE" -eq 1 ]; then
            LATEST_BACKUP=$(find_latest_backup "$SOURCE_FILE")
            if [ -z "$LATEST_BACKUP" ] || [ ! -e "$LATEST_BACKUP" ]; then TARGET_BACKUP="$SOURCE_FILE.bak"; else TARGET_BACKUP="$LATEST_BACKUP"; fi
        else
            BACKUP_FILE="$SOURCE_FILE.bak"
            COUNTER=1
            while [ -e "$BACKUP_FILE" ]; do BACKUP_FILE="$SOURCE_FILE.bak.$COUNTER"; ((COUNTER++)); done
            TARGET_BACKUP="$BACKUP_FILE"
        fi

        local COMMAND=""
        if [ "$USE_MV_FOR_BACKUP" -eq 1 ]; then COMMAND="mv -f"; echo "Action: Moving source file to '$TARGET_BACKUP'."; else COMMAND="cp -pf"; echo "Action: Copying source file to '$TARGET_BACKUP'."; fi

        $COMMAND "$SOURCE_FILE" "$TARGET_BACKUP"

        if [ $? -eq 0 ]; then echo "Operation successful."; else echo "Error: Operation failed."; fi
    fi
}

# --- Iterate over all provided filenames ---
for file in "${FILENAMES[@]}"; do
    process_file "$file"
done
